---
title: "3-1. Complexity Theory (1)"
date: 2024-10-01 00:01:00 +0900
categories: [학부 수업, (3-2) Cryptography]
tags: [cryptography]     # TAG names should always be lowercase
math: true
mermaid: true
---

### [3.1] Decision Problem
---
암호학에서 Complexity Theory가 중요한 이유가 뭘까? 공격자가 암호를 알아내기 위해서는 풀 수 있는 문제여야 한다. 반대로 풀 수 없는 문제일 경우 공격자는 암호를 알아낼 수 없다. 따라서 지금부터는 어떤 문제가 풀 수 있고 풀 수 없는지에 대해서 알아보자. 

Complexity Thoery에서 다루는 문제는 답이 Yes 또는 No로 정해지는 **Decision Problem** 이다.
- Decision Problem 문제는 증명하기가 쉽기 때문에 다룬다. 근데 이것만 다뤄도 충분하다!
- ex) shortest path 문제: $s$에서 $t$로 가는 길을 찾고 싶다. 이 문제를 Decision Problem으로 바꿔도 똑같이 풀 수 있다.

#### Terminologies
- $\text{Alphabet}$: any finite set, 각각의 원소는 symbols. 이 수업에서 $$\Sigma = \{0, 1\}$$ 로 정의한다.
- $\text{String}$: any finite sequence of symbols
- $\lambda$: empty string (길이가 0인 문자열)
- $\text{Language}$: any set of strings

#### What is a Problem?
$$\Sigma = \{0, 1\}$$일 때 모든 문자열의 집합을 $$\Sigma ^* = \{ \lambda, 0, 1, 00, 01, 10, 001, ... \} $$와 같이 표현한다.

우리가 다루려는 Decision Problem은 입력이 $\Sigma ^*$일 때 모두 Yes 또는 No의 답을 내야 한다.

**그중에서 답이 Yes인 String만 모은 집합이 Language이다! 따라서, Language를 Decision Problem과 같은 것이라고 생각할 수 있다.**

- $\textbf{Language = Problem}$
- $x \in L \iff \text{the answer to the problem is Yes for x}$

### [3.2] Size of Strings, Problems, Solutions
---
> **모든 문자열의 개수는?**
{: .prompt-tip}

$$\Sigma = \{0, 1\}$$ 이라고 하면 $$\Sigma ^* = \{ \lambda, 0, 1, 00, 01, 10, 001, ... \} $$ 이다. 각각에 자연수 번호를 붙일 수 있으므로 이 String의 개수는 자연수 집합의 개수와 같다. (Countable)

$$\therefore \vert \Sigma^* \vert = \vert \mathbb{N} \vert = \aleph_0 $$ 

> **모든 Problem의 개수는? (즉, Language의 개수)**
{: .prompt-tip}

Language는 $\Sigma^* $의 부분집합이다. 따라서, 모든 Language의 집합은 $\Sigma^* $의 멱집합인 $2^{\Sigma^*}$가 되고, 이는 $\vert \mathbb{R} \vert$ 실수 집합의 개수와 같다. (Uncountable)

$$\therefore \vert 2^{\Sigma^*} \vert = \vert \mathbb{R} \vert = 2^{\aleph_0} $$ 

#### Solution
- 문제에 대한 솔루션은 **Turing Machine**이다. (증명의 단순화를 위해 사용)
- Turing Machine은 프로그램이고, 프로그램은 어떤 문자열로 표현이 가능하므로 Turing Machine의 개수는 Countable하다.
- **문제는 Uncountable인데 솔루션은 Countable하다! 따라서 대부분의 문제는 솔루션이 없는 문제이다.**

하지만 대부분의 문제는 의미를 생각할 수 없다. 그렇다면 우리가 의미를 이해할 수 있는 문제(Describable Problem)의 개수는 얼마일까? 의미를 이해할 수 있다는 것은 문자열로 설명할 수 있는 문제이므로 개수가 $\vert \mathbb{N} \vert $으로 Countable하다. 그럼 Solution의 개수도$ \vert \mathbb{N} \vert $ 이니까 Describable problem은 모두 솔루션이 있을까?

### [3.3] Classes
---
- $\text{Class}$: Set of Problems
- Class의 개수는 Problem의 멱집합의 개수이므로 $\vert 2^\mathbb{R} \vert$ 만큼 있다.
- Describable Class의 개수는 문자열로 설명가능해야 하므로 Countable하다.

#### Class DFA
DFA가 풀 수 있는 Language들의 집합을 Class DFA라고 부른다.

- $L_1:$ 입력이 짝수인 문자열들의 집합
- $L_2:$ 입력이 0으로 끝나는 문자열들의 집합
- $L_3:$ 입력이 101을 포함하는 문자열들의 집합
- $$L_4:$$ $$\{ x \mid x = 0^i 1^j \text{ for some } i, j \ge 0\}$$
- $$L_5:$$ $$\{ x \mid x = 0^i 1^i \text{ for some } i, \ge 0\}$$

$L_1 \sim L_4$는 Class DFA에 속한다. 하지만, $L_5$는 pumping lemma가 통하지 않는 문자열이기 때문에 DFA가 풀 수 없는 문제이므로 Class DFA에 속하지 않는다.

#### Class NFA
- NFA는 같은 input에 대해 다른 결과를 낼 수 있다. (transition relation을 사용하기 때문)
- NFA는 input에 대해 하나라도 final state에 도착하면 accept한다.
- **Class DFA == Class NFA** 이다. (Equivalent Power)
- **NFA는 실제로 존재하지 않는 기계이다. DFA로 바꾸면 상태가 $2^k$개로 매우 많아지지만 실제로 표현 가능하게 된다!**

#### Class DPDA
- $L_5$을 accept 하는 기계: Deterministic Pushdown Automata
 
Pushdown은 stack을 의미한다. 이는 정보를 저장할 수 있다는 것을 의미한다. $L_5$의 경우 입력이 끝난 후 accept state에 있더라도 **stack이 비어있지 않으면 accept 하지 않는다!**

- $$L_6:$$ $$\{ x \mid x = y2y^R, x \in \{0, 1\}^* \}$$

이 문제도 DPDA가 $2$가 나올때까지 stack에 push하고 그 이후부터는 다 pop하면 풀 수 있다.

- $$L_7:$$ $$\{ x \mid x = yy^R, x \in \{0, 1\}^* \}$$

그럼 마커인 $2$가 없어지면 어떻게 될까? DPDA는 어디서부터 pop을 해야하는지를 결정할 수 없다. 즉, DPDA가 만족하는 pumping lemma가 성립하지 않기 때문에 이는 풀 수 없는 문제이다.

#### Class NPDA
Nondeterministic Pushdown Automata는 모든 경우의 수를 동시에 고려하기 때문에 $L_7$을 풀 수 있다. 따라서 DPDA가 풀 수 있는 문제보다 NPDA가 풀 수 있는 문제가 더 많다.

- **Class DPDA != NPDA**

- $$ L_8$$ $$: \{ x \mid x = y2y^R2y^R, y \in \{0,1\}^* \} $$
- $$ L_9$$ $$: \{ x \mid x = y2y^R2y^R2y^R, y \in \{0,1\}^* \} $$
- $$ L_{10}$$ $$: \{ x \mid x = yy^Ryy^R, y \in \{0,1\}^* \} $$
- $$ L_{11}$$ $$: \{ x \mid x = yy^Ry^Ry^R, y \in \{0,1\}^* \} $$

사실 위의 문제들은 모두 스택이 $2$개인 DPDA가 풀 수 있다. (스택이 $2$개인 DPDA는 Turing Machine과 Class가 동일하다.)

- $$ L_{12}$$ $$: \{ x \mid x = yy, y \in \{0,1\}^* \} $$

같은 것이 두 번 나오는 $L_{12}$는 NPDA도 풀 수 없는 문제이다.

#### Class DTM, NTM (Turing Machine)
Turing Machine이 가장 강력한 기계이다. 이 기계가 풀 수 없는 문제는 어떤 기계도 풀 수 없는 문제이다!
- DTM(Deterministic Turing Machine): $(Q, \Sigma, T, q, F, s)$
- Transition Function $s:$ $(q, a) \rightarrow (r, b, L/R/S)$
- 이 기계는 Yes 또는 No 또는 '종료되지 않는다' 라는 세 가지 결과가 존재할 수 있다.
- $$ L_{13}$$ $$: \{ x \mid x = y2y, y \in \{0,1\}^* \} $$ - 튜링머신은 이를 풀 수 있다.

- Universal Turing Machine: 튜링머신을 시뮬레이션할 수 있는 튜링머신이다. 테이프의 어떤 한 symbol을 기준으로 왼쪽은 튜링머신의 설계도를 $0, 1$로 인코딩한 값을, 오른쪽은 입력값을 작성한다.
- Chruch-Turing Thesis: 튜링머신보다 더 강력한 기계는 없다!
- Class DTM == NTM (Nondeterministic이 되어도 튜링머신의 능력은 같다.)

#### Acceptance of Turing Machine
지금까지 다룬 DFA, NFA, PDA 등에서 Language를 푼다, Accept한다는 의미는 그 Language에 속하는 String을 받으면 Yes, 아니면 No라고 출력하는 것이였다. 튜링머신은 Accept한다는 의미가 두가지가 존재한다.

1.  $M$ **enumerates** $L$
- $x \in L \iff M(x)$가 정지한다.
2. $M$ **decides** $L$
- $M(x)$가 항상 정지할 때, $x \in L$ 이면 yes를, $x \notin L$이면 no를 출력한다.


### [3.4] Class E, Co-E, D
---
- **Class E**: $$\{ L \mid \text{There exists a TM M that enumerates L} \}$$
- **Class co-E**: $$ \{ T \mid T^c \in E\} $$
- **Class D**: $$\{ L \mid \text{There exists a TM M that decides L} \}$$

1. Language $L$이 **Class E**에 속한다는 의미는 $L$의 원소들을 나열하는 방식으로 풀 수 있는 어떤 튜링머신 $M$이 존재한다는 의미이다. 만약 $L$에 들어있지 않는 입력을 튜링머신 $M$에 주면 $M$은 멈추지 않고 무한히 돌아간다.
2. **Class co-E는 Class E의 여집합이 아니다!** Class E에 속하는 Language들의 원소들의 여집합을 가지고 co-E라고 지칭한다.
3. Language $L$이 **Class D**에 속한다는 의미는 모든 입력에 대해 Yes 또는 No를 출력하는 어떤 튜링머신 $M$이 존재한다는 의미이다. 즉, $M$은 $L$에 있는 값이면 Yes를 출력하고, $L$에 있지 않는 값을 넣으면 No를 출력한다.

#### Why is it called Enumerable?
$L$이 class E에 들어있다는 것은 어떤 튜링머신 $M$이 존재하고, $x$가 $L$에 있으면 $M(X)$는 정지한다는 의미이다.

$$ L \in E \rightarrow \exists \text{ M, M(x) halts iff } x \in L $$

어떤 입력을 넣은 $M$은 정지하지만, 어떤 입력은 영원히 정지하지 않을 수 있다. 이를 어떻게 구분할까? Dovetailing Technique을 사용하여 왜 튜링머신 $M$이 모든 원소를 Enumerate 할 수 있는지를 증명할 수 있다.

어떤 튜링머신 $M_E$는 Class E에 속하는 $L$의 모든 원소를 출력하는 기계이다. 이 기계를 어떻게 만들 수 있을까?

1. 모든 존재하는 문자열 $\lambda, 0, 1, 00, 01, 10, \dots$ 를 $M$의 입력으로 넣는다고 가정하자.
2. $M(\lambda)$를 한번 돌리고, 그 다음 단계에선 $M(\lambda)$와 $M(0)$을 돌리고, 이와 같은 방식으로 반복하면 모든 기계를 돌릴 수 있다.
3. 이 과정을 반복하는 중 어떤 기계는 정지를 할 것이다. 그 정지한 기계의 입력을 출력하면? 당연하게도 $L$의 원소일 것이다.
4. 따라서 이 과정을 무한히 반복하면 $L$의 어떤 원소든 반드시 출력하게 되어있다.

$$ 
\begin{array}{|c|c|c|c|c|c|}
\hline
\textbf{M(x)} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} \\
\hline
M(\lambda) & 1 & 2 & 4 & 7 & 11\\
\hline
M(0)    & 3 & 5 &8 & 12 \\
\hline
M(1)      & 6 & 9 & 13 \\
\hline
M(00)     & 10& 14 \\
\hline
M(01)    & 15 \\
\hline
\vdots  & \vdots \\
\hline
\end{array}
$$

#### Enumerate in Lexicographical Order (Godel Order)
> Godel Order: $\lambda, 0, 1, 00, 01, 10, \dots$ 와 같이 길이순으로 우선 정렬한 후 사전순으로 정렬하는 방식

$L$의 크기는 무한하고, Class E와 D는 다르다고 가정한자.
위에서 $M_E$는 $L$의 원소를 Enumerate 할 수 있다는 것을 보였지만, **Lexicographical Order (Godel Order)로 나열할 수는 없다!** (어떤 기계가 끝나는지 안 끝나는지 알 수 없기 때문)

> **어떤 $L$을 Lexicographical Order로 출력할 수 있으면, $L \in D$ 이다.** 
{: .prompt-info}

**Proof by construction**
1. 튜링머신 $M$이 $L$을 Decide한다고 가정하자. 그리고 $L$을 Lexicographical Order로 출력하는 기계를 $M_1$이라 하자.
2. $X$가 $L$의 원소인지 확인하기 위해 $M(X)$를 찾는다.
3. $M$은 $M_1()$을 돌려서 나온 사전순으로 정렬된 결과를 확인한다. 
- 만약 $M_1$의 결과에 $X$가 있으면 $M$은 정지하고 `Yes`를 출력한다.
- 만약 $M_1$의 결과에 $X$보다 사전순으로 뒤에 나오는 값이 나오면 $M$은 정지하고 `No`를 출력한다.

따라서 튜링머신 $M$은 존재한다. 즉, $L \in D$이다.

### [3.5] $D = E \cap \text{co-E}$
---
> $D \subset E$
{: .prompt-tip}
1. $D$의 원소 $L$을 accept 하는 튜링머신울 $M$이라 하자.
2. 튜링머신 $M_E$는 $M$이 Yes를 출력하면 정지하고, No를 출력하면 안멈추게 하자. 그러면 $M_E$는 Class $E$에 속하는 $L$을 accept하는 기계에 속한다.
3. 따라서, Class $D$의 모든 원소는 Class $E$의 원소이다.

Language 들의 집합을 그림으로 그려보면 다음과 같다. 

![cr3](assets/img/school_cry/cr3.png)

위에서 Class D는 Class E 안에 속한다고 증명했다. 그럼 Class D는 정확히 어느 위치에 속할까? 정답은 정확히 $E$와 $\text{co-E}$ 사이의 교집합이다. 즉, $D = E \cap \text{co-E}$이다. 

- $D = E \cap \text{co-E}$임을 증명하기 위해서는 (1) 왼쪽 집합이 오른쪽 집합의 부분집합이고, (2) 오른쪽 집합이 왼쪽 집합의 부분집합임을 보이면 된다.
- $A \subset B$를 증명하기 위해서는 $x \in A$ 이면 모두 $x \in B$임을 보이면 된다.

> (1) $D \subset E \cap \text{co-E}$
{: .prompt-tip}

##### 1) $D \subset E \cap \text{co-E}$
- $D \subset E \text{  AND  } D \subset \text{co-E}$ 임을 보이자.
- $\text{If  } L \in D, \text{  then  } L \in E \text{  AND  } \text{If  } L \in D, \text{  then  } L \in \text{co-E}$ 임을 보이자.

1. $L \in D$이면, $x \in L$이면 Yes를 출력하고 $x \notin L$이면 No를 출력하는 어떤 튜링머신 $M$이 존재한다. (정의)
  - $M$이 Yes를 출력하면 정지하고, No를 출력하면 무한루프에 빠지게 하는 튜링머신 $M_1$을 만들어보자.
  - $M_1$은 Class $E$에 속하는 $L$을 accept 하는 기계이다. 따라서, $L \in E$이다.
2. $L \in D$이면, $x \in L$이면 Yes를 출력하고 $x \notin L$이면 No를 출력하는 어떤 튜링머신 $M$이 존재한다. (정의)
  - $M$이 Yes를 출력하면 무한 루프에 빠지고, No를 출력하면 정지하게 하는 튜링머신 $M_2$를 만들어보자.
  - $M_2$는 Class $\text{co-E}$에 속하는 $L$을 accept 하는 기계이다. 따라서, $L \in \text{co-E}$이다.

##### 2) $E \cap \text{co-E} \subset D$
- $\text{If  } L \in E \text{  AND  } L \in \text{co-E} , \text{  then  } L \in D$ 임을 보이자.
1. $L \in E$이면, $x \in L$이면 정지하고 $x \notin L$이면 정지하지 않는 어떤 튜링머신 $M_1$이 존재한다. (정의)
2. $L \in \text{co-E}$이면, $x \in L$이면 정지하지 않고 $x \notin L$이면 정지하는 어떤 튜링머신 $M_2$가 존재한다. (정의)
3. $M_1$과 $M_2$를 동시에 시뮬레이션하는 기계 $M$을 만들어보자. 어떤 입력 $x$에 대해서도 두 기계 중 하나는 반드시 정지한다. $M_1(x)$이 정지했으면 $x \in L$이고, $M_2(x)$가 정지했으면 $x \notin L$이므로 $M$은 $L$을 Decide 할 수 있다. 따라서, $L \in D$이다.


### [3.6] Halting Problem
---
Halting Problem은 다음과 같다.

$$ HALTING = \{ (M, x) \mid M(x) \text{  halts} \}$$

- $M$은 튜링머신의 소스코드이고, $x$는 입력이다. 즉 $HALTING$은 정지하는 모든 프로그램과 입력의 쌍을 의미한다.

#### Halting is in $E$ $(H \in E)$
Universal Turing Machine으로 Halting 문제를 enumerate할 수 있다. $M, x$ 입력에 따라 $M(x)$가 정지하면 출력하면 되고 정지하지 않으면 애초에 그 집합의 결과가 아니다.

#### Halting is NOT in $D$ $(H \notin D)$
1. $H \in D$ 라고 가정하자. (귀류법 가정)
2. $(M, x) \in H$ 이면 Yes, $(M, x) \notin H$이면 No를 출력하는 어떤 튜링머신 $M_D$가 존재한다. (Yes이면 $M(x)$가 정지하고, No이면 $M(x)$가 정지하지 않는다.)
3. $M_D$를 가지고 다음 튜링머신 $M_R$을 만들어보자.
  - $M_R$은 $(M, x) \in H$ 이면 Not halt, $(M, x) \notin H$이면 halt한다.
  - 즉, $M(x)$가 정지하면 정지하지 않고, $M(x)$가 정지하지 않으면 정지한다.
4. $M_R$을 가지고 다음 튜링머신 $S$를 만들어보자.
  - $S(M) = M_R(M, M)$ : 튜링머신 자체를 입력으로 받는다.
  - 위의 정의에 따라 $M(M)$이 정지하면 $S(M)$은 정지하지 않고, $M(M)$이 정지하지 않으면 $S(M)$은 정지한다.
5. 튜링머신 $S$에 입력으로 $S$를 넣으면 어떻게 될까?
  - **$S(S)$가 정지하면 $S(S)$는 정지하지 않고, $S(S)$가 정지하지 않으면 $S(S)$는 정지한다!!**
6. 따라서, $M_D$가 존재한다는 가정이 잘못되었고, $H \notin D$이다.

$$\therefore$$ Halting은 E에 있고 D에는 없다!